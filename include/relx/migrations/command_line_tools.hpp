#pragma once

#include "core.hpp"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <functional>
#include <optional>

namespace relx::migrations::cli {

/// @brief Print usage information for a migration command-line tool
/// @param program_name The name of the program executable
/// @param supported_versions List of supported version strings (e.g., {"v1", "v2", "v3"})
void print_usage(const char* program_name, const std::vector<std::string>& supported_versions = {}) {
    std::cout << "Usage: " << program_name << " [options]\n"
              << "Options:\n"
              << "  --generate FROM TO [--output FILE]  Generate migration from version FROM to TO\n"
              << "  --create VERSION [--output FILE]    Generate CREATE TABLE migration\n"
              << "  --drop VERSION [--output FILE]      Generate DROP TABLE migration\n"
              << "  --help                               Show this help\n\n";
    
    if (!supported_versions.empty()) {
        std::cout << "Supported versions: ";
        for (size_t i = 0; i < supported_versions.size(); ++i) {
            std::cout << supported_versions[i];
            if (i < supported_versions.size() - 1) std::cout << ", ";
        }
        std::cout << "\n\n";
    }
    
    std::cout << "Examples:\n"
              << "  " << program_name << " --generate v1 v2 --output migration_v1_to_v2.sql\n"
              << "  " << program_name << " --create v2\n"
              << "  " << program_name << " --drop v1 --output drop_users.sql\n";
}

/// @brief Print usage information for a migration command-line tool with customizable options
/// @param program_name The name of the program executable
/// @param supported_versions List of supported version strings (e.g., {"v1", "v2", "v3"})
/// @param create_available Whether CREATE table functionality is available
/// @param drop_available Whether DROP table functionality is available
void print_usage(const char* program_name, const std::vector<std::string>& supported_versions, 
                 bool create_available, bool drop_available) {
    std::cout << "Usage: " << program_name << " [options]\n"
              << "Options:\n"
              << "  --generate FROM TO [--output FILE]  Generate migration from version FROM to TO\n";
    
    if (create_available) {
        std::cout << "  --create VERSION [--output FILE]    Generate CREATE TABLE migration\n";
    }
    if (drop_available) {
        std::cout << "  --drop VERSION [--output FILE]      Generate DROP TABLE migration\n";
    }
    
    std::cout << "  --help                               Show this help\n\n";
    
    if (!supported_versions.empty()) {
        std::cout << "Supported versions: ";
        for (size_t i = 0; i < supported_versions.size(); ++i) {
            std::cout << supported_versions[i];
            if (i < supported_versions.size() - 1) std::cout << ", ";
        }
        std::cout << "\n\n";
    }
    
    std::cout << "Examples:\n"
              << "  " << program_name << " --generate v1 v2 --output migration_v1_to_v2.sql\n";
    
    if (create_available) {
        std::cout << "  " << program_name << " --create v2\n";
    }
    if (drop_available) {
        std::cout << "  " << program_name << " --drop v1 --output drop_users.sql\n";
    }
}

/// @brief Write a migration to a SQL file with proper formatting
/// @param migration The migration to write
/// @param filename The output filename
/// @param include_rollback Whether to include rollback SQL as comments (default: true)
void write_migration_to_file(const Migration& migration, const std::string& filename, bool include_rollback = true) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open file " << filename << " for writing\n";
        return;
    }
    
    file << "-- Migration: " << migration.name() << "\n";
    file << "-- Generated by relx migration tool\n";
    file << "-- Operations: " << migration.size() << "\n\n";
    
    auto forward_sqls = migration.forward_sql();
    file << "-- Forward Migration\n";
    for (size_t i = 0; i < forward_sqls.size(); ++i) {
        file << "-- Step " << (i + 1) << "\n";
        file << forward_sqls[i] << "\n\n";
    }
    
    if (include_rollback) {
        auto rollback_sqls = migration.rollback_sql();
        file << "-- Rollback Migration (for reference)\n";
        file << "-- Execute these in order to rollback:\n";
        for (size_t i = 0; i < rollback_sqls.size(); ++i) {
            file << "-- " << rollback_sqls[i] << "\n";
        }
    }
    
    file.close();
    std::cout << "Migration written to: " << filename << "\n";
}

/// @brief Print a migration to the console with formatting
/// @param migration The migration to print
void print_migration(const Migration& migration) {
    std::cout << "\n=== Migration: " << migration.name() << " ===\n";
    std::cout << "Operations: " << migration.size() << "\n\n";
    
    auto forward_sqls = migration.forward_sql();
    std::cout << "Forward Migration SQL:\n";
    for (size_t i = 0; i < forward_sqls.size(); ++i) {
        std::cout << (i + 1) << ". " << forward_sqls[i] << "\n";
    }
    
    auto rollback_sqls = migration.rollback_sql();
    std::cout << "\nRollback Migration SQL:\n";
    for (size_t i = 0; i < rollback_sqls.size(); ++i) {
        std::cout << (i + 1) << ". " << rollback_sqls[i] << "\n";
    }
    std::cout << "\n";
}

/// @brief Command-line argument parsing result
struct CommandLineArgs {
    enum class Command {
        HELP,
        GENERATE,
        CREATE,
        DROP,
        INVALID
    };
    
    Command command = Command::INVALID;
    std::string from_version;
    std::string to_version;
    std::string version;
    std::string output_file;
    std::string error_message;
};

/// @brief Parse command-line arguments for migration tools
/// @param args Command-line arguments (excluding program name)
/// @return Parsed arguments structure
CommandLineArgs parse_args(const std::vector<std::string>& args) {
    CommandLineArgs result;
    
    if (args.empty()) {
        result.error_message = "No arguments provided";
        return result;
    }
    
    if (args[0] == "--help") {
        result.command = CommandLineArgs::Command::HELP;
        return result;
    }
    else if (args[0] == "--generate") {
        if (args.size() < 3) {
            result.error_message = "--generate requires FROM and TO versions";
            return result;
        }
        
        result.command = CommandLineArgs::Command::GENERATE;
        result.from_version = args[1];
        result.to_version = args[2];
        
        // Check for --output option
        for (size_t i = 3; i < args.size(); ++i) {
            if (args[i] == "--output" && i + 1 < args.size()) {
                result.output_file = args[i + 1];
                break;
            }
        }
    }
    else if (args[0] == "--create") {
        if (args.size() < 2) {
            result.error_message = "--create requires version";
            return result;
        }
        
        result.command = CommandLineArgs::Command::CREATE;
        result.version = args[1];
        
        // Check for --output option
        for (size_t i = 2; i < args.size(); ++i) {
            if (args[i] == "--output" && i + 1 < args.size()) {
                result.output_file = args[i + 1];
                break;
            }
        }
    }
    else if (args[0] == "--drop") {
        if (args.size() < 2) {
            result.error_message = "--drop requires version";
            return result;
        }
        
        result.command = CommandLineArgs::Command::DROP;
        result.version = args[1];
        
        // Check for --output option
        for (size_t i = 2; i < args.size(); ++i) {
            if (args[i] == "--output" && i + 1 < args.size()) {
                result.output_file = args[i + 1];
                break;
            }
        }
    }
    else {
        result.error_message = "Unknown command: " + args[0];
    }
    
    return result;
}

/// @brief Migration generator function type for version-to-version migrations
using MigrationGenerator = std::function<Migration(const std::string&, const std::string&)>;

/// @brief Create table migration generator function type
using CreateMigrationGenerator = std::function<Migration(const std::string&)>;

/// @brief Drop table migration generator function type  
using DropMigrationGenerator = std::function<Migration(const std::string&)>;

/// @brief Run a complete migration command-line tool
/// @param argc Command-line argument count
/// @param argv Command-line argument values
/// @param supported_versions List of supported version strings
/// @param migration_generator Function to generate migrations between versions
/// @param create_generator Optional function to generate create table migrations
/// @param drop_generator Optional function to generate drop table migrations
/// @return Exit code (0 for success, non-zero for error)
int run_migration_tool(
    int argc, 
    char* argv[],
    const std::vector<std::string>& supported_versions,
    MigrationGenerator migration_generator,
    std::optional<CreateMigrationGenerator> create_generator = std::nullopt,
    std::optional<DropMigrationGenerator> drop_generator = std::nullopt
) {
    bool create_available = create_generator.has_value();
    bool drop_available = drop_generator.has_value();
    
    if (argc < 2) {
        print_usage(argv[0], supported_versions, create_available, drop_available);
        return 1;
    }
    
    std::vector<std::string> args(argv + 1, argv + argc);
    auto parsed_args = parse_args(args);
    
    try {
        switch (parsed_args.command) {
            case CommandLineArgs::Command::HELP:
                print_usage(argv[0], supported_versions, create_available, drop_available);
                return 0;
                
            case CommandLineArgs::Command::GENERATE: {
                auto migration = migration_generator(parsed_args.from_version, parsed_args.to_version);
                
                if (!parsed_args.output_file.empty()) {
                    write_migration_to_file(migration, parsed_args.output_file);
                } else {
                    print_migration(migration);
                }
                break;
            }
            
            case CommandLineArgs::Command::CREATE: {
                if (!create_generator.has_value()) {
                    std::cerr << "Error: CREATE table functionality is not available. "
                              << "The create migration generator was not provided to this tool.\n";
                    return 1;
                }
                
                auto migration = (*create_generator)(parsed_args.version);
                
                if (!parsed_args.output_file.empty()) {
                    write_migration_to_file(migration, parsed_args.output_file);
                } else {
                    print_migration(migration);
                }
                break;
            }
            
            case CommandLineArgs::Command::DROP: {
                if (!drop_generator.has_value()) {
                    std::cerr << "Error: DROP table functionality is not available. "
                              << "The drop migration generator was not provided to this tool.\n";
                    return 1;
                }
                
                auto migration = (*drop_generator)(parsed_args.version);
                
                if (!parsed_args.output_file.empty()) {
                    write_migration_to_file(migration, parsed_args.output_file);
                } else {
                    print_migration(migration);
                }
                break;
            }
            
            case CommandLineArgs::Command::INVALID:
                std::cerr << "Error: " << parsed_args.error_message << "\n";
                print_usage(argv[0], supported_versions, create_available, drop_available);
                return 1;
        }
    }
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }
    
    return 0;
}

}  // namespace relx::migrations::cli 