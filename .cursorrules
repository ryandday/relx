Conventions

Use top level makefile to build / run / test stuff



# C++ Coding Standards for SQLlib

## Language Version
- Use C++23 as the primary standard 

- Minimum compiler requirements:
  - GCC 11+
  - Clang 14+
  - MSVC 19.29+ (Visual Studio 2022+)

## Modern C++ Features

### Use Concepts Instead of SFINAE
Prefer concepts over traditional template metaprogramming techniques:

```cpp
// Avoid this C++17 approach
template <typename T, 
          typename = std::enable_if_t<std::is_integral_v<T> || std::is_floating_point_v<T>>>
void process(T value);

// Prefer this C++20 approach
template <typename T>
concept Numeric = std::integral<T> || std::floating_point<T>;

template <Numeric T>
void process(T value);
```

### Core Concepts to Define
Create custom concepts for the library's central abstractions:

```cpp
// Table concept
template <typename T>
concept TableType = requires(T t) {
    { T::table_name } -> std::convertible_to<std::string_view>;
    { t.columns() } -> std::ranges::range;
};

// Column concept
template <typename T>
concept ColumnType = requires(T t) {
    { T::column_name } -> std::convertible_to<std::string_view>;
    typename T::value_type;
};

// Query concept
template <typename T>
concept QueryExpr = requires(T t) {
    { t.to_sql() } -> std::convertible_to<std::string>;
    { t.bind_params() } -> std::ranges::range;
};
```

### Use Auto Where Appropriate
- Use `auto` for iterator types, lambdas, and complex return types
- Use explicit types for function parameters, class member variables, and when clarity is needed

### Use Structured Bindings
Prefer structured bindings for multi-return values:
```cpp
auto [sql, params] = query.to_sql_and_params();
```

### Range-Based For Loops
Prefer range-based for loops over iterator-based loops:
```cpp
for (const auto& row : results) {
    // ...
}
```

### Lambda Expressions
- Use lambdas for short-lived operations and callbacks
- Don't use a catch all capture by reference or value (`[&]`, `[=]`), explicitly capture the variables you need.
- Capture specific variables by value (`[value]`) for lambdas that might outlive local variables

### constexpr and consteval
- Use `constexpr` liberally for functions that can be evaluated at compile time
- Use `consteval` for functions that must be evaluated at compile time

### std::string_view and std::span
- Use `std::string_view` for non-owning string references
- Use `std::span` for non-owning array/container references

## Template Design

### Favor Composition Over Inheritance
- Use template composition for building query components
- Avoid deep inheritance hierarchies

### Type Traits and Reflection
- Define clear type traits for mapping between C++ and SQL types

## Error Handling

### Use std::expected (C++23) Where Available
```cpp
template <typename T>
using Result = std::expected<T, DatabaseError>;

Result<ResultSet> execute_query(const Query& query);
```

### Use std::optional for Nullable Returns
```cpp
std::optional<int> get_value();
```

### Throw Exceptions for Programming Errors
- Use exceptions for truly exceptional conditions and programming errors
- Define a clear exception hierarchy

## Naming Conventions

### Types and Concepts
- Use PascalCase for type names, concept names, and template parameters
- Append concept names with `Concept` suffix:
  ```cpp
  template <typename T>
  concept TableConcept = /* ... */;
  ```

### Functions and Methods
- Use snake_case for function and method names:
  ```cpp
  auto execute_query(const Query& query);
  ```

### Variables
- Use snake_case for variable names
- Use meaningful, descriptive names

### Member Variables
- Use snake_case with trailing underscore for member variables:
  ```cpp
  class Connection {
  private:
      std::unique_ptr<ConnectionImpl> impl_;
      bool is_connected_;
  };
  ```

### Constants and Enums
- Use PascalCase for enum names, constants, and enum values:
  ```cpp
  enum class IsolationLevel {
      ReadUncommitted,
      ReadCommitted,
      RepeatableRead,
      Serializable
  };
  ```

## Code Organization

### Header Structure
- Include guards should use `#pragma once`
- Order includes as follows:
  1. Related header for this implementation
  2. C++ standard library headers
  3. Third-party library headers
  4. Project headers
- Separate include groups with blank lines

### Namespaces
- Place code in the `sqllib` namespace
- Use nested namespaces for major subsystems:
  ```cpp
  namespace sqllib::detail {
      // Implementation details
  }
  ```

### File Naming
- Use snake_case for filenames
- Use `.hpp` for header files, `.cpp` for implementation files

## Code Style

### Formatting
- Max line length: 120 characters
- Indent with 4 spaces (no tabs)
- Use clang-format with the provided configuration file

### Comments
- Use `//` for most comments
- Use `///` for documentation comments
- Use Doxygen-style comments for public APIs

### Headers
All headers should have documentation for classes, functions, etc.:

```cpp
/// @brief Connection class for database access
/// @details Provides a type-safe interface for executing SQL queries
class Connection {
public:
    /// @brief Execute a query and return results
    /// @param query A query expression
    /// @return Result set containing query results
    /// @throws ConnectionException if the connection is closed
    template <QueryExpr Query>
    ResultSet execute(const Query& query);
};
```

## Testing

### Test Framework
- Use Google Test for testing
- Create a test for each class and major function
- Avoid mocking or dependency injection, use real database connections.

### Test Organization
- Group tests by functionality
- Name tests descriptively

## Performance Considerations

### Compile-Time Evaluation
- Prefer compile-time evaluation where possible
- Use `constexpr` and `consteval` for SQL string generation

### Avoid Virtual Functions in Hot Paths
- Use static polymorphism (CRTP, concepts) for hot paths
- Reserve virtual functions for external interfaces

### Memory Management
- Minimize memory allocations in hot paths
- Use `std::string_view`, `std::span`, and reference types where appropriate